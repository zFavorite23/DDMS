{"remainingRequest":"D:\\DDMS\\node_modules\\babel-loader\\lib\\index.js!D:\\DDMS\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\DDMS\\src\\role.js","dependencies":[{"path":"D:\\DDMS\\src\\role.js","mtime":1588235430032},{"path":"D:\\DDMS\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\DDMS\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\DDMS\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport _defineProperty from \"D:\\\\DDMS\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport router from \"./router/index\";\nimport store from \"./store/index\";\nimport NProgress from \"nprogress\"; // Progress 进度条\n\nimport \"nprogress/nprogress.css\"; // Progress 进度条样式\n\nimport { getUserId } from \"./utils/auth\"; // 验权\n\nimport { Message } from \"element-ui\";\nimport { asyncRouterMap } from \"./router/index\"; // permissiom judge\n\nfunction hasRole(authRules, permissionAuthRules) {\n  if (!authRules || authRules.length <= 0) {\n    return false;\n  }\n\n  if (authRules.indexOf(\"admin\") >= 0) return true; // admin权限 直接通过\n\n  if (!permissionAuthRules) return true;\n  return authRules.some(function (role) {\n    return permissionAuthRules.indexOf(role) >= 0;\n  });\n}\n/**\r\n * 通过meta.role判断是否与当前用户权限匹配\r\n * @param authRules\r\n * @param route\r\n */\n\n\nfunction hasRouterRole(authRules, route) {\n  if (authRules.indexOf(\"admin\") >= 0 || !route.meta || !route.meta.authRule) {\n    return true;\n  }\n\n  return authRules.some(function (authRule) {\n    return route.meta.authRule.indexOf(authRule) >= 0;\n  });\n}\n/**\r\n * 递归过滤异步路由表，返回符合用户角色权限的路由表\r\n * @param asyncRouterMap\r\n * @param authRules\r\n */\n\n\nfunction filterAsyncRouter(asyncRouterMap, authRules) {\n  var accessedRouters = asyncRouterMap.filter(function (route) {\n    if (hasRouterRole(authRules, route)) {\n      if (route.children && route.children.length) {\n        route.children = filterAsyncRouter(route.children, authRules);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return accessedRouters;\n} // register global progress.\n\n\nvar whiteList = [\"/login\", \"/401\", \"/404\", \"/500\"]; // 不重定向白名单\n\nrouter.beforeEach(function (to, from, next) {\n  NProgress.start(); // 开启Progress\n\n  if (whiteList.indexOf(to.path) !== -1) {\n    // 在免登录白名单，直接进入\n    next();\n    return;\n  }\n\n  var userId = getUserId();\n\n  if (userId !== \"undefined\" && userId !== \"\" && userId) {\n    // 判断是否有token\n    if (to.path === \"/login\") {\n      next({\n        path: \"/\"\n      });\n      NProgress.done(); // router在hash模式下 手动改变hash 重定向回来 不会触发afterEach 暂时hack方案 ps：history模式下无问题，可删除该行！\n\n      return;\n    }\n\n    if (!store.getters.userName && (!store.getters.authRules || store.getters.authRules.length === 0)) {\n      // 判断当前用户是否已拉取完用户信息\n      store.dispatch(\"userInfo\").then(function (data) {\n        // 拉取user_info\n        var authRules = data.roles || [];\n\n        if (!(authRules instanceof Array) || authRules.length === 0) {\n          Message.error(\"权限验证失败，请联系管理员~\");\n          next({\n            path: \"/401\",\n            query: {\n              noGoBack: true\n            }\n          });\n          NProgress.done();\n          return;\n        }\n\n        var accessedRouters = filterAsyncRouter(asyncRouterMap, authRules); // 生成可访问的路由表\n\n        router.addRoutes(accessedRouters); // 动态添加可访问路由表\n\n        next(_objectSpread({}, to)); // hack方法 确保addRoutes已完成\n        // 设置左边导航栏\n\n        store.dispatch(\"filterRouter\", {\n          accessedRouters: accessedRouters\n        }).then(function () {});\n      }).catch(function () {\n        store.dispatch(\"fedLogout\").then(function () {\n          Message.error(\"验证失败,请重新登录\");\n          var redirect = to.fullPath;\n          store.dispatch(\"loginOut\").then(function () {\n            next({\n              path: \"/login\",\n              query: {\n                redirect: redirect\n              }\n            });\n          });\n        });\n      });\n      return;\n    } // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n\n\n    if (hasRole(store.getters.authRules, to.meta.authRule)) {\n      next(); //\n\n      return;\n    }\n\n    next({\n      path: \"/401\",\n      query: {\n        noGoBack: true\n      }\n    });\n    NProgress.done(); // router在hash模式下 手动改变hash 重定向回来 不会触发afterEach 暂时hack方案 ps：history模式下无问题，可删除该行！\n\n    return;\n  }\n\n  var redirect = to.fullPath;\n  store.dispatch(\"loginOut\").then(function () {\n    next({\n      path: \"/login\",\n      query: {\n        redirect: redirect\n      }\n    });\n  }); // 否则全部重定向到登录页\n\n  NProgress.done(); // router在hash模式下 手动改变hash 重定向回来 不会触发afterEach 暂时hack方案 ps：history模式下无问题，可删除该行！\n});\nrouter.afterEach(function () {\n  NProgress.done(); // 结束Progress\n});",{"version":3,"sources":["D:/DDMS/src/role.js"],"names":["router","store","NProgress","getUserId","Message","asyncRouterMap","hasRole","authRules","permissionAuthRules","length","indexOf","some","role","hasRouterRole","route","meta","authRule","filterAsyncRouter","accessedRouters","filter","children","whiteList","beforeEach","to","from","next","start","path","userId","done","getters","userName","dispatch","then","data","roles","Array","error","query","noGoBack","addRoutes","catch","redirect","fullPath","afterEach"],"mappings":"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","sourcesContent":["import router from \"./router/index\";\r\nimport store from \"./store/index\";\r\nimport NProgress from \"nprogress\"; // Progress 进度条\r\nimport \"nprogress/nprogress.css\"; // Progress 进度条样式\r\nimport { getUserId } from \"./utils/auth\"; // 验权\r\nimport { Message } from \"element-ui\";\r\nimport { asyncRouterMap } from \"./router/index\";\r\n// permissiom judge\r\nfunction hasRole(authRules, permissionAuthRules) {\r\n    if (!authRules || authRules.length <= 0) {\r\n        return false;\r\n    }\r\n    if (authRules.indexOf(\"admin\") >= 0) return true; // admin权限 直接通过\r\n    if (!permissionAuthRules) return true;\r\n    return authRules.some(role => permissionAuthRules.indexOf(role) >= 0);\r\n}\r\n\r\n/**\r\n * 通过meta.role判断是否与当前用户权限匹配\r\n * @param authRules\r\n * @param route\r\n */\r\nfunction hasRouterRole(authRules, route) {\r\n    if (\r\n        authRules.indexOf(\"admin\") >= 0 ||\r\n        !route.meta ||\r\n        !route.meta.authRule\r\n    ) {\r\n        return true;\r\n    }\r\n    return authRules.some(\r\n        authRule => route.meta.authRule.indexOf(authRule) >= 0\r\n    );\r\n}\r\n\r\n/**\r\n * 递归过滤异步路由表，返回符合用户角色权限的路由表\r\n * @param asyncRouterMap\r\n * @param authRules\r\n */\r\nfunction filterAsyncRouter(asyncRouterMap, authRules) {\r\n    const accessedRouters = asyncRouterMap.filter(route => {\r\n        if (hasRouterRole(authRules, route)) {\r\n            if (route.children && route.children.length) {\r\n                route.children = filterAsyncRouter(route.children, authRules);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n    return accessedRouters;\r\n}\r\n\r\n// register global progress.\r\nconst whiteList = [\"/login\", \"/401\", \"/404\", \"/500\"]; // 不重定向白名单\r\n\r\nrouter.beforeEach((to, from, next) => {\r\n    NProgress.start(); // 开启Progress\r\n    if (whiteList.indexOf(to.path) !== -1) {\r\n        // 在免登录白名单，直接进入\r\n        next();\r\n        return;\r\n    }\r\n    let userId = getUserId();\r\n\r\n    if (userId !== \"undefined\" && userId !== \"\" && userId) {\r\n        // 判断是否有token\r\n        if (to.path === \"/login\") {\r\n            next({ path: \"/\" });\r\n            NProgress.done(); // router在hash模式下 手动改变hash 重定向回来 不会触发afterEach 暂时hack方案 ps：history模式下无问题，可删除该行！\r\n            return;\r\n        }\r\n        if (\r\n            !store.getters.userName &&\r\n            (!store.getters.authRules || store.getters.authRules.length === 0)\r\n        ) {\r\n            // 判断当前用户是否已拉取完用户信息\r\n            store\r\n                .dispatch(\"userInfo\")\r\n                .then(data => {\r\n                    // 拉取user_info\r\n                    const authRules = data.roles || [];\r\n                    if (\r\n                        !(authRules instanceof Array) ||\r\n                        authRules.length === 0\r\n                    ) {\r\n                        Message.error(\"权限验证失败，请联系管理员~\");\r\n                        next({\r\n                            path: \"/401\",\r\n                            query: { noGoBack: true }\r\n                        });\r\n                        NProgress.done();\r\n                        return;\r\n                    }\r\n                    let accessedRouters = filterAsyncRouter(\r\n                        asyncRouterMap,\r\n                        authRules\r\n                    );\r\n                    // 生成可访问的路由表\r\n                    router.addRoutes(accessedRouters); // 动态添加可访问路由表\r\n                    next({ ...to }); // hack方法 确保addRoutes已完成\r\n                    // 设置左边导航栏\r\n                    store\r\n                        .dispatch(\"filterRouter\", { accessedRouters })\r\n                        .then(() => {});\r\n                })\r\n                .catch(() => {\r\n                    store.dispatch(\"fedLogout\").then(() => {\r\n                        Message.error(\"验证失败,请重新登录\");\r\n                        let redirect = to.fullPath;\r\n                        store.dispatch(\"loginOut\").then(() => {\r\n                            next({\r\n                                path: \"/login\",\r\n                                query: { redirect: redirect }\r\n                            });\r\n                        });\r\n                    });\r\n                });\r\n            return;\r\n        }\r\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\r\n        if (hasRole(store.getters.authRules, to.meta.authRule)) {\r\n            next(); //\r\n            return;\r\n        }\r\n        next({\r\n            path: \"/401\",\r\n            query: { noGoBack: true }\r\n        });\r\n        NProgress.done(); // router在hash模式下 手动改变hash 重定向回来 不会触发afterEach 暂时hack方案 ps：history模式下无问题，可删除该行！\r\n        return;\r\n    }\r\n    let redirect = to.fullPath;\r\n    store.dispatch(\"loginOut\").then(() => {\r\n        next({\r\n            path: \"/login\",\r\n            query: { redirect: redirect }\r\n        });\r\n    }); // 否则全部重定向到登录页\r\n    NProgress.done(); // router在hash模式下 手动改变hash 重定向回来 不会触发afterEach 暂时hack方案 ps：history模式下无问题，可删除该行！\r\n});\r\n\r\nrouter.afterEach(() => {\r\n    NProgress.done(); // 结束Progress\r\n});\r\n"]}]}